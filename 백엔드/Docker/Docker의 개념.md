# 도커를 쓰는 이유?

→ 어떠한 프로그램을 다운 받는 과정을 간단하게 만들어주기 때문에 사용

> 도커 없이 프로그램을 다운 받을 때
>

Installer(크롬이나 카카오톡 등등) 다운 → Install 실행 → 프로그램 설치 완료

이 과정에서 **ERROR**가 나는 경우가 있음

왜? → **갖고 있는 서버, 패키지 버전, 운영체제 등에 따라서 다 다르기 때문.**

**도커 없이 Redis를 받는 과정**

- Redis 홈페이지 이동 →터미널 켜서 Installation 명령어 입력 . → 에러 발생 이유는 ‘wget’이라는 라이브러리가 없어서 → wget 다운받아야함 → 등등...

**도커 있이 Redis를 받는 과정**

- `docker run -it redis` 만 치면 끝.

이렇게 도커를 이용하면 훨씬 더 간단하게 다운 받을 수 있다.

# 도커란?

> **컨테이너**를 사용하여 응용 프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구 이며 **컨테이너** 기반의 오픈소스 가상화 플랫폼이며 생태계
>

(실제로 도커 홈페이지에서 도커를 소개할때도 Why Docker 페이지= What is Container 페이지로 되어있을 만큼 도커에서는 컨테이너라는 개념이 굉장히 중요)

- **컨테이너?**

  일반적으로는 어떤 물건들을 넣고 다양한 운송수단으로 쉽게 옮길 수 있는 박스같은 개념

  서버에서의 컨테이너도 비슷하다.

  컨테이너 안에 다양한 프로그램(Mysql, Webpack, Redis같은), 실행환경을 넣어두고(컨테이너로 추상화, 동일한 인터페이스 제공) 프로그램의 배포 및 관리를 단순하게 해줌.

  그래서?

  → **컨테이너는 코드와 모든 종속성을 패키지화해서 응용프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위.**

- **컨테이너 이미지**

  **코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정**과 같은 **응용 프로그램을 실행**하는 데 필요한 **모든 것을 포함**하는 가볍고 독립적이며 실행 가능한 소프트웨어 패키지

  런타임에 컨테이너가 되고 컨테이너의 경우 도커 엔진에서 실행 될때 **이미지가 컨테이너가 됨**

  리눅스와 윈도우 기반 애플리케이션 모두에서 사용할 수 있는 컨테이너화 된 소프트웨어는 인프라에 관계없이 항상 동일하게 실행됨.

  **컨테이너는 소프트웨어를 환경으로부터 격리**시키고 개발과 스테이징의 차이에도 불구하고 균일하게 작동하도록 보장

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48740d71-c4c2-41e5-8040-143fd30b2380/Untitled.png)


→ **도커 이미지는 프로그램을 실행하는데 필요한 설정이나 종속성들을 갖고 있으며 도커 이미지를 이용해서 컨테이너를 생성하고 도커 컨테이너를 이용해서 프로그램을 실행한다.**

# 도커의 사용 흐름

도커 사용 과정

1. 도커 CLI에 커맨드를 입력한다.
2. 도커 서버(도커 Daemon)이 그 커맨드를 받아서 그것에 따라 이미지를 생성하든 컨테이너를 실행하든 모든 작업을 하게 된다.

도커 Client → 도커 Server(Daemon)

### 실제로 CLI에서 커맨드 입력

`docker run hello-world`

1. 이렇게 입력을 했을 경우 도커 서버로 요청을 보냄
2. 서버에서 hello-world 이미지가 이미 로컬에 chache 되어 있는지 확인
3. 현재는 없기 때문에 Unable to find image 라는 문구가 2번째 줄에 표시
4. 그러면 Docker Hub라는 이미지가 저장되더 있는 곳에 가서 그 이미지를 가져오고

   (터미널에서는 Pulling from library/hello-world 라는 문구가 뜸)로컬에 Chache 로 보관

5. 그 후에는 이제 이미지가 보관되어 있으니 그 이미지 이용해서 컨테이너 생성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3988f1ba-e1cc-429b-8dc4-0b04f7fde4a2/Untitled.png)

# 컨테이너의 이해

- 가상화 기술 나오기 전
    - 한 대의 서버를 하나의 용도로만 사용
    - 남는 서버 공간 그대로 방치
    - 하나의 서버에  하나의 운영체제, 하나의 프로그램만 운영
    - 안정적이긴 한데 비효율적임
- 하이퍼바이저 기반의 가상화 출현
    - **논리적으로 공간을 분할**해서 VM이라는 독립적인 가상 환경의 서버 이용 가능
    - 하이퍼 바이저는 호스트 시스템(윈도우나 리눅스)에서 다수의 게스트 OS를 구동할 수 있게 하는 SW
    - 하드웨어를 가상롸하면서 하드웨어와 각각의 vm을 모니터링 하는 **중간 관리자**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b75859f7-19f7-4dd8-b9a9-77d0b775a084/Untitled.png)

- **네이티브 하이퍼 바이저** : 하이퍼 바이저가 하드웨어를 직접 제어하기에 자원 효율적으로 사용가능 하며, 별도의 호스트 OS가 없으므로 오버헤드가 적다.

  하지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어려움

- **호스트형 하이퍼바이저**:  우리가 많이 쓰는 바이저는 ‘호스트형 하이퍼바이저’
    - 일반적인 소프트웨어처럼 호스트 os위에서 실행되며, 하드웨어 자원을 VM 내부의 게스트 OS에 에뮬레이르 하는 방식으로 오버헤드가 크다.

      하지만, 게스트 OS 종류에 대한 제약이 없고 구현이 다소 쉽다.


    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/faabd048-18d4-4d92-801b-1c91abe7cffd/Untitled.png)
    
    첫번째 VM에서 에러가 난다고 하더라도 격리가 된 채로, 분리가 되어 있으니 영향이 가지 않음.
    
    → **하이퍼 바이저에 의해 구동되는 VM은 각 VM마다 독립된 가상 하드웨어 자원을 할당 받는다. 논리적으로 분리되어 있어서 한 VM에 오류가 발생해도 다른 VM으로 퍼지지 않는다는 장점이 있음!**

- 이러한 가상화 기술에서 나온 컨테이너 가상화 기술

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4274b263-62e1-4dab-ab64-da23661cc2d9/Untitled.png)

  보면 기존 가상화 기술 구조와 도커 구조가 굉장히 유사하다는 것을 알 수 있음.

  → **공통점** : 도커 컨테이너와 가상 머신은 기본 하드웨어에서 격리된 환경 내에 어플리케이션을 배치하는 방법

  → **차이점** : 가장 큰 차이점은 격리된 환경을 얼마나 격리를 시키는지의 차이

    - VM과 비교했을 때 컨테이너는 하이퍼바이저와 게스트OS가 필요하지 않으므로 더 가벼움
    - 어플리케이션을 실행할 때는 컨테이너 방식에서는 호스트 OS위에 어플리케이션의 실행 패키지인 이미지를 배포하기만 하면 되는데 VM은 어플리케이션을 실행하기 위해서 VM을 띄우고 다원을 할당한 후에 게스트 OS를 부팅해서 어플리케이션을 실행해야 해서 훨씬 복잡하고 무겁게 실행을 해야한다.

- 도커 컨테이너
    - 돌아가는 애플리케이션은 컨테이너가 제공하는 격리 기능 내부에 샌드박스가 있지만, 여전히 같은 호스트의 다른 컨테이너와 동일한 커널을 공유

      결과적으로 컨테이너 내부에서 실행되는 프로세스는 호스트 시스템(모든 프로세스를 나열할 수 있는 충분한 권한이 있음)에서 볼 수 있다.

      예를 들어서, 도커와 함께 몽고 DB 컨테이너를 시작하면 호스트(도커X)의 일반 쉘에 ps-e grep 몽고를 실행하면 프로세스가 표시됨.

      그리고, 컨테이너가 전체OS를 내장할 필요가 없는 결과, 매우 가볍고 일반적으로 약 5-100MB정도의 크기이다.

- 가상머신
    - 이와 함게 VM내부에서 실행되는 모든 것은 호스트 운영체제 또는 하이퍼바이저와 독립되어있음. 가상머신 플랫폼은 특정 VM에 대한 가상화 프로세스를 관리하기 위해서 프로세스를 시작하고, 호스트 시스템은 그것의 하드웨어 자원의 일부를 VM에 할당한다.

      그러나 VM과 근본적으로 다른 것은 시작 시간에 이 VM환경을 위해 새롭고 이 특정 VM만을 위한 커널을 부팅하고 운영체제프로세스 세트를 시작한다는 것이다.

      이것은 응용프로그램만 포함하는 일반적인 컨테이너보다 VM의 크기를 훨씬 크게 만든다.

      OS까지 가상화(맥에서 윈도우를 깐다든지 리눅스에서 윈도우를 돌린다든지..) 하느 방법은 비교적 사용법이 간단할 수 있지만 굉장히 느리다.


![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/747e8a9e-2e8a-43d7-9ee9-0fa47dd10cb7/Untitled.png)

- 서로 다른 프로그램들끼리 같은 커널을 공유
- **그럼 위 그림에 나와있듯이 컨테이너들을 격리 시키는데 어떻게 해서 도커 컨테이너를 격리시킬까?** → 벽을 만드는 **리눅스 커널 기능**들을 이용
    - **C-Group**

      CPU, 메모리, Network Bandwith,HD/io등 프로세스 그룹의 시스템 리소스 사용량을 관리

      → 어떤 어플이 사용량이 너무 많다면 그 어플리케이션 같은 것을 C group에 집어 넣어서 CPU와 메모리 사용 제한 기능

    - **네임스페이스**

      하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술

      별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경향 프로레스 가상화 기술


    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/160abc5e-192f-4d0a-81c2-db7a5d5f9e15/Untitled.png)


# 이미지로 컨테이너 만들기

> 이미지는 응용 프로그램을 실행하는데 **필요한 모든 것**을 포함함
>

**필요한 모든것?**

1. 시작시 실행 될 명령어 : `run kakaotalk`
2. 파일 스냅샷 : 카카오톡을 실행할 파일(디렉토리나 파일을 카피한 것)

- 이미지로 컨테이너 만드는 순서
    1. Docker 클라에 `docker run <이미지>` 입력
    2. 도커 이미지에 있는 파일 스냅샷을 컨테이너 하드 디스크에 옮겨줌

       (ex. 하드디스크 부분에 파일 스냅샷(카카오톡 설치에 필요한 파일)을 넣어줌)

    3. 이미지에서 가지고 있는 명령어 (컨테이너가 실행될 때 사용될 명령어)를 이용해서 카카오톡 실행

       (ex. 컨테이너에다가 넣어줌)

    4. 그렇게 하면 컨테이너가 실행되고 명령어가 실행되면서 커널을 통해서 하드디스크의 카카오톡 실행파일이 작동되면서 카카오톡이 실행이되는 것

# Cgroup과 네임스페이스를 쓸 수 있는 이유

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a4686af6-9ce1-43b6-af2c-3c31a4247828/Untitled.png)

Cgroup과 네임스페이스는 리눅스 기능들임!

Docker cli에서 `docker version`을 쳐보자.

쳐보면 Server 도커에 해당하는 OS가 **리눅스**로 나오는 것을 확인할 수 있다.

**실제 구조**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45a5f9fc-cd17-4a73-8abc-0fe34470cbb9/Untitled.png)