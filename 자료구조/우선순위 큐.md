** 보통의 큐는 선입선출의 원칙에 의해서 먼저 들어온 데이터가 먼저 나가게 된다.**

> 우선순위 큐에서는 데이터들이 우선순위를 가지고 있고 우선 순위가 높은 데이터가 먼저 나가게 된다.
>

| 자료구조 | 삭제되는 요소 |
| --- | --- |
| 스택 | 가장 최근에 들어온 데이터 |
| 큐 | 가장 먼저 들어온 데이터 |
| 우선순위큐 | 가장 우선순위가 높은 데이터 |
- 사용 분야
    - 시뮬레이션 시스템
    - 네트워크 트래픽 제어
        - 네트워크 패킷 중에서 네트워크 관리와 관련된 패킷은 다른 일반 패킷보다 우선 순위를 가지게 된다.
    - 운영체제에서의 작업 스케줄링, 수치 해석적인 계산
- 우선순위 큐는 배열, 연결 리스트 등의 여러가지 방법으로 구현이 가능한데, 가장 효율적인 구조는 히프이다.
- 각 요소들은 우선 순위값을 가지고 있고 가장 중요한 연산은 **`insert 연산 (요소 삽입)`**, **`delete(요소 삭제)`**이다.

### 두 가지로 구분

1. **최소 우선순위 큐**는 가장 우선 순위가 낮은 요소를 먼저 삭제
2. **최대 우선순위 큐**는 반대로 가장 우선 순위가 높은 요소가 먼저 삭제

- `**배열을 사용하는 방법**`

  삽입은 그냥 하면 되니까 맨 끝에 새로운 요소를 추가하면 된다. → 시간 복잡도 O(1)

  BUT 삭제는 가장 우선 순위가 높은 요소를 찾아야하는데

    1. 정렬이 안되어있으면 처음부터 끝까지 모든 요소들을 스캔하여야 하므로 O(n) 의 시간 복잡도를 가진다.
    2. 정렬이 되어있다면 삽입할때 적절한 위치를 결정해야하므로 순차 탐색이나 이진 탐색을 이용할 수 있다.  → 시간 복잡도 O(n)

       그 대신, 삭제가 용이, 숫자가 높은것이 우선순위가 높다고 가정하면 맨 뒤에 위치한 요소를 삭제하면 된다. → 시간 복잡도 O(1)


- **`연결 리스트를 사용하는 방법`**

    1. 정렬이 안된 리스트이면 삽입 시에 배열과 달리 다른 노드를 이동할 필요가 없고 포인터만 변경하면 된다. → 시간 복잡도 O(1)

       삭제 시에는 시간 복잡도 O(n)

    2. 정렬이 되어있는 리스트이면, 우선 순위가 높은 요소가 앞에 위치하는 것이 유리 따라서 높은 요소가 첫 번째 노트가 되도록 한다. 삽입시에는 우선 순위 값 기준으로 삽입 위치를 찾아야하므로 O(n)이 되고 삭제 시에는 첫번째 노드를 삭제하면 되므로 O(1)이다.
- **`히프를 사용하는 방법`**

  > 일종의 느슨한 정렬 상태를 유지. 즉, 완전히 정렬된 것은 아니지만 전혀 정렬이 안된 것도 아닌 상태를 유지
    - 히프의 효율은 O(log2n)으로서 상당히 유리.(O(n)알고리즘이 1000초가 걸린다면 O(log2n)은 10초)
    - 히프는 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조.
    - 부모노드의 키 값이 자식 노드의 키 값보다 항상 큰 이진 트리

  > key(부모노드) ≥ key(자식노드)

  ![](https://velog.velcdn.com/images/kansun12/post/17dd2ceb-910d-4cd4-9f9b-e978ecf15ec3/image.png)
  
    히프트리에서는 중복 값을 허용
    
    → 큰 값이 상위 레벨에 있고 작은 값이 하위 헤벨에 있다는 정도. 히프의 목적은 삭제 연산이 수행될 때마다 가장 큰 값을 찾아내기만 하면 되므로 (가장 큰 값은 루트노드겠다!) 
    
    = **전체 정렬이 필요 없다.**
    
    > 히프는 **완전 이진 트리**
    > 
    
    - 히프의 종류
        
        ![](https://velog.velcdn.com/images/kansun12/post/d2ac943b-f28e-4f05-a8e5-26a7eb07dac1/image.png)
        - 최대힙
        - 최소힙
    - 히프를 구현 할때에는 보통 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
    
    ![](https://velog.velcdn.com/images/kansun12/post/eb88109e-efdf-4335-bd23-d310f2f1faee/image.png)
    
    주의할 점은 특정 위치의 노드번호는 새로운 노드가 추가되어도 변하지 않는다 .
    
    ![](https://velog.velcdn.com/images/kansun12/post/9bb279b6-1c04-41ff-99a1-2f36aff73f95/image.png)

    히프트리에서의 자식 노드와 부모노드의 관계
    
    어떤 노드의 왼쪽이나 오른쪽 **자식의 인덱스**를 알고 싶으면 다음과 같은 식을 이용하면 된다.
    
    - 왼쪽 자식의 인덱스 = **`(부모의 인덱스) * 2`**
    - 오른쪽 자식의 인덱스 = **`(부모의 인덱스) * 2 +1`**
    
    **부모의 인덱스**를 알고 싶으면 다음과 같은 식을 이용
    
    - 부모의 인덱스 = **`(자식의 인덱스)/2`**
    
    ### 히프의 구현
    
    - **`히프정의`**
        
        ```c
        //히프 정의
        #define MAX_ELEMENT 200
        typedef struct {
        	int key;
        }element;
        typedef struct {
        	element heap[MAX_ELEMENT];
        	int heap_size;
        }HeapType;
        
        //히프 생성
        HeapType heap;
        //메모리 동적으로 할당
        HeapType *heap=create();
        ```
        
    - **삽입 연산**
        
        삽입 하면 힙의 마지막 노드로 삽입되고 이 마지막 노드에 다음 새로운 노드를 또 위치시키면 히프트리의 성질이 만족되지 않을 수 있다. 
        
        따라서 삽입 후에 새로운 노드를 부모노드들과  교환해서 히프의 성질을 만족시켜주어야한다.
        
        ![](https://velog.velcdn.com/images/kansun12/post/183725a5-ebe6-4bb9-b5f8-bf6616ee8a91/image.png)
        
        - **알고리즘**
            
            ```
            insert_max_heap(A,key):
            
            1. heap_size <- heap_size + 1;
            2. i <- heap_size;
            3. A[i] <- key;
            4. while i ≠ 1 and A[i] > A[PARENT(i)] do
            5.    A[i] <-> A[PARENT];
            6.    i <- PARENT(i);
            ```
            
            1. 히프 크기를 하나 증가시킨다.
            2. 증가된 히프크기 위치에 새로운 노드를 삽입한다.
            
             4.  i가 루트 노드가 아니고 i번째 노드가 i의 부모 노드보다 크면
            
            1. i번째 노드와 부모노드를 교환
            2. 한 레벨 위로 올라간다.
        - **구현 코드**
            
            ```c
            //현재 요소의 개수가 heap_size인 히프, h에 item을 삽입
            //삽입 함수
            void insert_max_heap(HeapType* h, element item){
            	int i;
            	i = ++(h -> heap_size);
            	//트리를 거슬러 올라가면서 부모 노드와 비교하는 과정
            	while ((i!=1) && (item.key > h->heap[i/2].key)){
            		h->heap[i] = h->heap[i/2];
            		i/= 2;
            	}
            	h->heap[i]=item; //새로운 노드를 삽입
            ```
            
    - **삭제 연산**
        
        ![](https://velog.velcdn.com/images/kansun12/post/11874629-9d4b-4aa2-949b-3f01bda182fd/image.png)
        
        - 삭제 연산은 최대값을 가진 요소를 삭제 하는 것이다. 최대 히프에서 최대값은 루트노드이므로 루트노드가 삭제된다.
        - 루트 노드 삭제 후에 히프를 재구성하는 것이 필요하게 된다. 히프의 재구성이란 히프의 성질을 만족하기 위해 위, 아래 노드를 교환 하는 것이다.
        - **알고리즘**
            
            ```
            delete_max_heap(A) :
            
            1. item <- A[i];
            2. A[i] <- A[heap_size];
            3. heap_size <-heap_size-1;
            4. i <-2;
            5. while i <= heap_size do
            6.    if i<heap_size and A[i+1] > A[i]
            7.       then largest <- i+1;
            8.       else largest <- i;
            9.    if A[PARENT(largest)] > A[largest]
            10.      then break;
            11.   A[PARENT(largest)] <-> A[largest];
            12.   i <- CHILD(largest);
            13.
            14.return item;
            ```
            
            1. 루트 노드 값을 반환을 위하여 item 변수로 옮긴다.
            2. 말단 노드를 루트 노드로 옮긴다.
            3. 히프의 크기를 하나 줄인다.
            4. 루트의 왼쪽 자식부터 비교를 시작한다.
            5. i가 히프 트리의 크기보다 작으면 (즉, 히프트리를 벗어나지 않았으면)
            6. 오른쪽 자식이 더 크면
            
            7-8. 두개의 자식 노드 중 큰 값의 인덱스를 largest로 옮긴다.
            
            1. largest 의 부모 노드가 largest보다 크면
            2. 중지
            3. 그렇지 않으면 largest와 largest 부모 노드를 교환한다.
            4. 한 레벨 밑으로 내려간다.
            
            14. 최대값을 반환한다.
            
        - **구현 코드**
            
            ```c
            element delete_max_heap(HeapType* h){
            	int parent, child;
            	element item, temp;
            
            	item = h->heap[i];
            	temp = h->heap[(h->heap_size)--];
            	parent = 1;
            	child = 2;
            	while(child <= h->heap_size) {
            		// 현재 노드의 자식노드 중 더 큰 자식 노드를 찾는다.
            		if((child <= h->heap_size)&&(h->heap[child].key) < h->heap[child+1].key)
            			child++;
            		if(temp.key >= h->heap[child].key) break;
            		//한 단계 아래로 이동
            		h->heap[parent] = h-> heap[child];
            		parent = child;
            		child *= 2;
            	}
            	h->heap[parent] = temp;
            	return item;
            ```
---
- **히프의 복잡도**

  삽입 연산에서 새로운 요소 히프틀리를 타고 올라가면서 부모노드들과 교환을 하게 되는데, 최악의 경우  루트 노드까지 올라가야하므로 트리의 높이에 해당하게 되는 것!

  히프가 완전이진트리임을 생각하면 시간 복잡도 O(log2n)이 된다.

  삭제도 마찬가지로 마지막 노드를 루트로 가져온 후에 자식 노드들과 비교하여 교환하는 부분이 가장 시간이 걸리는 부분인데 최악의 경우, 가장 아래 레벨까지 내려가야하므로 역시 트리의 높이만큼의 시간이 걸린다. 다라서 삭제의 시간 복잡도도 O(log2n)

  | 표현방법 | 삽입 | 삭제 |
      | --- | --- | --- |
  | 순서없는 배열 | O(1) | O(n) |
  | 순서없는 연결리스트 | O(1) | O(n) |
  | 정렬된 배열 | O(n) | O(1) |
  | 정렬된 연결 리스트 | O(n) | O(1) |
  | 히프 | O(logn) | O(logn) |
    